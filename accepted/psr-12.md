## PSR-12: Расширенный Стиль Кодирования

Ключевые слова 'ДОЛЖНЫ', 'НЕ ДОЛЖНЫ', 'ТРЕБУЕТСЯ', 'НУЖНО', 'НЕ НУЖНО', 'СЛЕДУЕТ', 'НЕ СЛЕДУЕТ', 'РЕКОМЕНДУЕТСЯ', 'МОЖЕТ' и 'НЕОБЯЗАТЕЛЬНО' в этом документе должны толковаться так, как описано в [RFC 2119](../rfc2119.md).

#### 1. Обзор

Эта спецификация расширяет и заменяет руководство по стилю кодирования PSR-2 и требует соблюдения PSR-1, основного стандарта кодирования.

Как и PSR-2, цель данной рекомендации, уменьшить когнитивные трения при просмотре кода разных авторов. Это достигается путем перечисления общего набора правил и ожиданий о том, как форматировать код на PHP. Этот PSR стремится обеспечить набор способов, который может реализовать механизмы стиля кодирования. Проекты могут заявить о соблюдении, а разработчики могут легко устанавливать связь между различными проектами. Когда разные авторы имеют дело с несколькими проектами, это помогает иметь один набор стиля кодирования, который будет использоваться среди всех этих проектов. Таким образом, преимущество этого руководства заключается не в самих правилах, а в совместном использовании этих правил.

PSR-2 был принят в 2012 году, и с тех пор в PHP был внесен ряд изменений, которые повлияли на рекомендации по стилю кодирования. В то время как PSR-2 полно отражает функциональность PHP, существовавшую на момент написания, новая функциональность хорошо раскрыта для понимания. Таким образом, этот PSR стремится прояснить содержание PSR-2 в более современном контексте с доступными новыми функциональными возможностями и сделать поправки к PSR-2.

###### Предыдущие версии языка

На протяжении всего этого документа любые инструкции МОГУТ быть проигнорированы, если они не существуют в версиях PHP, поддерживаемых вашим проектом.

###### Пример

Этот пример включает в себя некоторые из приведенных ниже правил в качестве краткого обзора:

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // Тело метода
    }
}
```

#### 2. Общее

###### 2.1 Базовый Стандарт Кодирования

Код ДОЛЖЕН соответствовать всем правилам, изложенным в PSR-1.

Термин "StudlyCaps" в PSR-1 ДОЛЖЕН интерпретироваться как "PascalCase", где первая буква каждого слова пишется с большой буквы, включая самую первую букву.

###### 2.2 Файлы

Все файлы PHP ДОЛЖНЫ использовать только конец строки Unix LF (перевод строки).

Все файлы PHP ДОЛЖНЫ заканчиваться непустой строкой, заканчивающейся одним LF.

Закрывающий тег `?>` ДОЛЖЕН быть опущен в файлах, содержащих только PHP код.

###### 2.3 Строки

Здесть НЕ ДОЛЖНО быть жесткого ограничения на длину строки.

Слабое ограничение на длину строки ДОЛЖНО быть 120 символов.

Строки НЕ ДОЛЖНЫ быть длиннее 80 символов. Длинные строки ДОЛЖНЫ быть разбиты на несколько строк, длиной не более 80 символов.

В конце строк НЕ ДОЛЖНО быть завершающих пробелов.

Пустые строки МОГУТ быть добавлены для улучшения читабельности и для обозначения связанных блоков кода, за исключением случаев, когда это явно запрещено.

В каждой строке НЕ ДОЛЖНО быть более одного оператора.

###### 2.4 Отступ

В коде ДОЛЖЕН использоваться отступ в 4 пробела для каждого уровня отступа. Для отступа НЕ ДОЛЖНА использоваться табуляция.

###### 2.5 Ключевые слова и типы

Все зарезервированные в PHP [ключевые слова][keywords] и [типы][types] ДОЛЖНЫ быть в нижнем регистре.

Любые новые типы и ключевые слова, добавленные в будущих версиях PHP, ДОЛЖНЫ быть в нижнем регистре.

НЕОБХОДИМО использовать краткую форму ключевых слов типа, т.е. `bool` вместо `boolean`, `int` вместо `integer` и т. Д.

#### 3. Операторы declare, Пространства Имен и Операторы Импорта

Заголовок файла PHP может состоять из нескольких различных блоков. Если заголовок присутствует, каждый из нижеприведенных блоков ДОЛЖЕН быть разделен одной пустой строкой и блок НЕ ДОЛЖЕН содержать пустых строк. Каждый блок ДОЛЖЕН быть в указанном ниже порядке, если блоки неуместны, то могут быть опущены.

* Открывающий тег `<?php`.
* Файловый doc-блок.
* Одно или несколько операторов declare.
* Объявление пространства имен файла.
* Один или несколько операторов импорта `use` на основе классов.
* Один или несколько операторов импорта `use` на основе функций.
* Один или несколько операторов импорта `use` на основе констант.
* Остальная часть кода в файле.

Когда файл содержит комбинацию HTML и PHP, любой из вышеперечисленных блоков все еще может использоваться. Если это так, то блоки ДОЛЖНЫ присутствовать в верхней части файла, даже если остальная часть кода состоит из закрывающего тега PHP, и только потом комбинация HTML и PHP.

Открывающий тег `<?php` находится в первой строке файла, он ДОЛЖЕН находиться в отдельной строке без других операторов, если это не файл, содержащий разметку вне открывающих и закрывающих тегов PHP.

Операторы импорта НЕ ДОЛЖНЫ начинаться с обратной косой черты, поскольку они всегда должны быть полностью отвечать требованиям.

Следующий пример демонстрирует полный список всех блоков:

```php
<?php

/**
 * Этот файл содержит пример стилей кодирования.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar - это примерный класс.
 */
class FooBar
{
    // ... вспомогательный код PHP ...
}
```

Составные пространства имен с глубиной более двух НЕ ДОЛЖНЫ использоваться. Ниже приведен максимальный компромисс допустимой глубины:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

А следующие действия не допускаются:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};
```

При желании установить директиву строгой типизации в файлах, содержащих разметку вне открывающих и закрывающих тегов PHP, установка ДОЛЖНА быть в первой строке файла и включать открывающий тег PHP, объявление строгой типизации и закрывающий тег.

Например:

```php
<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... вспомогательный код PHP ...
    ?>
</body>
</html>
```

Операторы declare ДОЛЖНЫ не содержать пробелов и ДОЛЖНЫ быть такими `declare(strict_types=1)` (с необязательным оканчиванием точкой с запятой).

Блок операторов declare допускается и ДОЛЖЕН быть отформатирован следующим образом. Обратите внимание на положение фигурных скобок и пробелов:

```php
<?php
declare(ticks=1) {
    // некоторый код
}
```

#### 4. Классы, Методы и Свойства

Термин "класс" относится ко всем классам, интерфейсам и трейтам.

Любая закрывающая скобка НЕ ДОЛЖНА сопровождаться комментарием или оператором в той же строке.

При создании экземпляра нового класса круглые скобки ДОЛЖНЫ присутствовать всегда, даже если в конструктор не передаются никакие аргументы.

```php
new Foo();
```

###### 4.1 Наследование и Реализации Интерфейса

НЕОБХОДИМО, чтобы ключевые слова `extends` и `implements` были объявлены в той же строке, что и имя класса.

Открывающая скобка для класса ДОЛЖНА идти отдельной строкой; закрывающая скобка для класса ДОЛЖНА идти на следующей строке после тела.

Открывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать или сопровождаться пустой строкой.

Закрывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать пустой строкой.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // константы, свойства, методы
}
```

Расширение `implements` класса и реализации `extends` интерфейсов МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один интерфейс на строку.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // константы, свойства, методы
}
```

###### 4.2 Использование трейтов

Ключевое слово `use`, используемое внутри классов для реализации трейтов, ДОЛЖНО быть объявлено на следующей строке после открывающей скобки.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

Каждый отдельный трейт, который импортируется в класс, ДОЛЖЕН быть расположен на отдельной строке, и каждое включение ДОЛЖНО иметь свой собственный оператор `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}
```

Когда у класса ничего нет после оператора импорта `use`, закрывающая скобка класса ДОЛЖНА быть на следующей строке после оператора `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

В противном случае он ДОЛЖЕН иметь пустую строку после оператора импорта `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}
```

Операторы `insteadof` и `as` ДОЛЖНЫ использоваться следующим образом, принимая во внимание отступы, интервалы и новые строки.

```php
<?php

class Talker
{
    use A;
    use B {
        A::smallTalk insteadof B;
    }
    use C {
        B::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}
```

###### 4.3 Свойства и Константы

Видимость ДОЛЖНА быть объявлена для всех свойств.

Видимость ДОЛЖНА быть объявлена для всех констант, если минимальная версия вашего проекта поддерживает видимость констант (PHP 7.1 и выше).

Ключевое слово `var` НЕ ДОЛЖНО использоваться для объявления свойства.

В каждом выражении НЕ ДОЛЖНО быть объявлено более одного свойства.

Имена свойств НЕ ДОЛЖНЫ иметь префикс с одним подчеркиванием для обозначения защищенной или приватной видимости. Другими словами префикс подчеркивания явно не имеет значения.

Между объявлением типа и именем свойства ДОЛЖЕН быть пробел.

Объявление свойства выглядит следующим образом:

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public $foo = null;
    public static int $bar = 0;
}
```

###### 4.4 Методы и Функции

Видимость ДОЛЖНА быть объявлена для всех методов.

Названия методов НЕ ДОЛЖНЫ иметь префикс с одним подчеркиванием для обозначения защищенной или приватной видимости. То есть префикс подчеркивания явно не имеет значения.

Названия методов и функций НЕ ДОЛЖНЫ быть объявлены с пробелом после названия метода. Открывающая фигурная скобка ДОЛЖНА идти по отдельной строке, а закрывающая фигурная скобка ДОЛЖНА переходить на следующую строку после тела. После открывающей скобки НЕ ДОЛЖНО быть пробела, и НЕ ДОЛЖЕН быть пробел перед закрывающей скобкой.

Объявление метода выглядит следующим образом. Обратите внимание на расположение обычных и фигурных скобок, запятых, пробелов:

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

Объявление функции выглядит следующим образом. Обратите внимание на расположение обычных и фигурных скобок, запятых, пробелов:

```php
<?php

function fooBarBaz($arg1, &$arg2, $arg3 = [])
{
    // тело функции
}
```

###### 4.5 Аргументы Метода и Функции

В списке аргументов НЕ ДОЛЖЕН быть пробел перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

Аргументы метода и функции со значениями по умолчанию ДОЛЖНЫ помещаться в конец списка аргументов.

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function foo(int $arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

Списки аргументов МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН находиться на следующей строке, и в каждой строке ДОЛЖЕН быть только один аргумент.

Когда список аргументов разбит на несколько строк, закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть помещены вместе в их собственную строку с одним пробелом между ними.

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // тело метода
    }
}
```

При наличии объявления возвращаемого типа после двоеточия, за которым следует объявление типа, ДОЛЖЕН быть один пробел. Двоеточие и объявление ДОЛЖНЫ находиться в той же строке, что и закрывающая скобка списка аргументов, без пробелов между двумя символами.

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(int $arg1, $arg2): string
    {
        return 'foo';
    }

    public function anotherFunction(
        string $foo,
        string $bar,
        int $baz
    ): string {
        return 'foo';
    }
}
```

В объявлениях типа Nullable НЕ ДОЛЖЕН быть пробел между знаком вопроса и типом.

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(?string $arg1, ?int &$arg2): ?string
    {
        return 'foo';
    }
}
```

При использовании оператора ссылки `&` перед аргументом НЕ ДОЛЖНО быть пробел после него, как и в предыдущем примере.

Между оператором многоточие `...` и именем аргумента не должно быть пробела:

```php
public function process(string $algorithm, ...$parts)
{
    // обработка
}
```

При объединении как оператора ссылки, так и оператора многоточие между ними не должно быть никакого пространства:

```php
public function process(string $algorithm, &...$parts)
{
    // обработка
}
```

###### 4.6 abstract, final, and static

Когда присутствуют, абстрактные `abstract` и окончательные `final` объявления они ДОЛЖНЫ предшествовать объявлению видимости.

При наличии статического объявления `static`, оно ДОЛЖНО следовать за объявлением видимости.

```php
<?php

namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // тело метода
    }
}
```

###### 4.7 Вызовы Методов и Функций

При вызове метода или функции не ДОЛЖНО быть пробела между именем метода или функции и открывающей скобкой, НЕ ДОЛЖНО быть пробела и после открывающей скобки и НЕ ДОЛЖНО быть пробела перед закрывающей скобкой. В списке аргументов перед каждой запятой НЕ ДОЛЖНО быть пробела, а после каждой запятой ДОЛЖЕН быть один пробел.

```php
<?php

bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);
```

Списки аргументов МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент списка ДОЛЖЕН находиться на следующей строке, и в каждой строке ДОЛЖЕН быть только один аргумент. Один аргумент, разбитый на несколько строк (как это может быть в случае с анонимной функцией или массивом), не является разбиением самого списка аргументов.

```php
<?php

$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
```

```php
<?php

somefunction($foo, $bar, [
  // ...
], $baz);

$app->get('/hello/{name}', function ($name) use ($app) {
    return 'Hello ' . $app->escape($name);
});
```





> Продолжение следует ...

[keywords]: https://www.php.net/manual/ru/reserved.keywords.php
[types]: https://www.php.net/manual/ru/reserved.other-reserved-words.php
