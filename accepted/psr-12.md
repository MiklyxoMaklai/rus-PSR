## PSR-12: Расширенный Стиль Кодирования

Ключевые слова 'ДОЛЖНЫ', 'НЕ ДОЛЖНЫ', 'ТРЕБУЕТСЯ', 'НУЖНО', 'НЕ НУЖНО', 'СЛЕДУЕТ', 'НЕ СЛЕДУЕТ', 'РЕКОМЕНДУЕТСЯ', 'МОЖЕТ' и 'НЕОБЯЗАТЕЛЬНО' в этом документе должны толковаться так, как описано в [RFC 2119](../rfc2119.md).

#### 1. Обзор

Эта спецификация расширяет и заменяет руководство по стилю кодирования PSR-2 и требует соблюдения PSR-1, основного стандарта кодирования.

Как и PSR-2, цель данной рекомендации, уменьшить когнитивные трения при просмотре кода разных авторов. Это достигается путем перечисления общего набора правил и ожиданий о том, как форматировать код на PHP. Этот PSR стремится обеспечить набор способов, который может реализовать механизмы стиля кодирования. Проекты могут заявить о соблюдении, а разработчики могут легко устанавливать связь между различными проектами. Когда разные авторы имеют дело с несколькими проектами, это помогает иметь один набор стиля кодирования, который будет использоваться среди всех этих проектов. Таким образом, преимущество этого руководства заключается не в самих правилах, а в совместном использовании этих правил.

PSR-2 был принят в 2012 году, и с тех пор в PHP был внесен ряд изменений, которые повлияли на рекомендации по стилю кодирования. В то время как PSR-2 полно отражает функциональность PHP, существовавшую на момент написания, новая функциональность хорошо раскрыта для понимания. Таким образом, этот PSR стремится прояснить содержание PSR-2 в более современном контексте с доступными новыми функциональными возможностями и сделать поправки к PSR-2.

###### Предыдущие версии языка

На протяжении всего этого документа любые инструкции МОГУТ быть проигнорированы, если они не существуют в версиях PHP, поддерживаемых вашим проектом.

###### Пример

Этот пример включает в себя некоторые из приведенных ниже правил в качестве краткого обзора:

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // Тело метода
    }
}
```

#### 2. Общее

###### 2.1 Базовый Стандарт Кодирования

Код ДОЛЖЕН соответствовать всем правилам, изложенным в PSR-1.

Термин "StudlyCaps" в PSR-1 ДОЛЖЕН интерпретироваться как "PascalCase", где первая буква каждого слова пишется с большой буквы, включая самую первую букву.

###### 2.2 Файлы

Все файлы PHP ДОЛЖНЫ использовать только конец строки Unix LF (перевод строки).

Все файлы PHP ДОЛЖНЫ заканчиваться непустой строкой, заканчивающейся одним LF.

Закрывающий тег `?>` ДОЛЖЕН быть опущен в файлах, содержащих только PHP код.

###### 2.3 Строки

Здесть НЕ ДОЛЖНО быть жесткого ограничения на длину строки.

Слабое ограничение на длину строки ДОЛЖНО быть 120 символов.

Строки НЕ ДОЛЖНЫ быть длиннее 80 символов. Длинные строки ДОЛЖНЫ быть разбиты на несколько строк, длиной не более 80 символов.

В конце строк НЕ ДОЛЖНО быть завершающих пробелов.

Пустые строки МОГУТ быть добавлены для улучшения читабельности и для обозначения связанных блоков кода, за исключением случаев, когда это явно запрещено.

В каждой строке НЕ ДОЛЖНО быть более одного оператора.

###### 2.4 Отступ

В коде ДОЛЖЕН использоваться отступ в 4 пробела для каждого уровня отступа. Для отступа НЕ ДОЛЖНА использоваться табуляция.

###### 2.5 Ключевые слова и типы

Все зарезервированные в PHP [ключевые слова][keywords] и [типы][types] ДОЛЖНЫ быть в нижнем регистре.

Любые новые типы и ключевые слова, добавленные в будущих версиях PHP, ДОЛЖНЫ быть в нижнем регистре.

НЕОБХОДИМО использовать краткую форму ключевых слов типа, т.е. `bool` вместо `boolean`, `int` вместо `integer` и т. Д.

#### 3. Операторы declare, Пространства Имен и Операторы Импорта

Заголовок файла PHP может состоять из нескольких различных блоков. Если заголовок присутствует, каждый из нижеприведенных блоков ДОЛЖЕН быть разделен одной пустой строкой и блок НЕ ДОЛЖЕН содержать пустых строк. Каждый блок ДОЛЖЕН быть в указанном ниже порядке, если блоки неуместны, то могут быть опущены.

* Открывающий тег `<?php`.
* Файловый doc-блок.
* Одно или несколько операторов declare.
* Объявление пространства имен файла.
* Один или несколько операторов импорта `use` на основе классов.
* Один или несколько операторов импорта `use` на основе функций.
* Один или несколько операторов импорта `use` на основе констант.
* Остальная часть кода в файле.

Когда файл содержит комбинацию HTML и PHP, любой из вышеперечисленных блоков все еще может использоваться. Если это так, то блоки ДОЛЖНЫ присутствовать в верхней части файла, даже если остальная часть кода состоит из закрывающего тега PHP, и только потом комбинация HTML и PHP.

Открывающий тег `<?php` находится в первой строке файла, он ДОЛЖЕН находиться в отдельной строке без других операторов, если это не файл, содержащий разметку вне открывающих и закрывающих тегов PHP.

Операторы импорта НЕ ДОЛЖНЫ начинаться с обратной косой черты, поскольку они всегда должны быть полностью отвечать требованиям.

Следующий пример демонстрирует полный список всех блоков:

```php
<?php

/**
 * Этот файл содержит пример стилей кодирования.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar - это примерный класс.
 */
class FooBar
{
    // ... вспомогательный код PHP ...
}
```

Составные пространства имен с глубиной более двух НЕ ДОЛЖНЫ использоваться. Ниже приведен максимальный компромисс допустимой глубины:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

А следующие действия не допускаются:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};
```

При желании установить директиву строгой типизации в файлах, содержащих разметку вне открывающих и закрывающих тегов PHP, установка ДОЛЖНА быть в первой строке файла и включать открывающий тег PHP, объявление строгой типизации и закрывающий тег.

Например:

```php
<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... вспомогательный код PHP ...
    ?>
</body>
</html>
```

Операторы declare ДОЛЖНЫ не содержать пробелов и ДОЛЖНЫ быть такими `declare(strict_types=1)` (с необязательным оканчиванием точкой с запятой).

Блок операторов declare допускается и ДОЛЖЕН быть отформатирован следующим образом. Обратите внимание на положение фигурных скобок и пробелов:

```php
<?php
declare(ticks=1) {
    // некоторый код
}
```

#### 4. Классы, Методы и Свойства

Термин "класс" относится ко всем классам, интерфейсам и трейтам.

Любая закрывающая скобка НЕ ДОЛЖНА сопровождаться комментарием или оператором в той же строке.

При создании экземпляра нового класса круглые скобки ДОЛЖНЫ присутствовать всегда, даже если в конструктор не передаются никакие аргументы.

```php
new Foo();
```

###### 4.1 Наследование и Реализации Интерфейса

НЕОБХОДИМО, чтобы ключевые слова `extends` и `implements` были объявлены в той же строке, что и имя класса.

Открывающая скобка для класса ДОЛЖНА идти отдельной строкой; закрывающая скобка для класса ДОЛЖНА идти на следующей строке после тела.

Открывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать или сопровождаться пустой строкой.

Закрывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать пустой строкой.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // константы, свойства, методы
}
```

Расширение `implements` класса и реализации `extends` интерфейсов МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один интерфейс на строку.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // константы, свойства, методы
}
```

###### 4.2 Использование трейтов

Ключевое слово `use`, используемое внутри классов для реализации трейтов, ДОЛЖНО быть объявлено на следующей строке после открывающей скобки.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

Каждый отдельный трейт, который импортируется в класс, ДОЛЖЕН быть расположен на отдельной строке, и каждое включение ДОЛЖНО иметь свой собственный оператор `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}
```

Когда у класса ничего нет после оператора импорта `use`, закрывающая скобка класса ДОЛЖНА быть на следующей строке после оператора `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

В противном случае он ДОЛЖЕН иметь пустую строку после оператора импорта `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}
```

Операторы `insteadof` и `as` ДОЛЖНЫ использоваться следующим образом, принимая во внимание отступы, интервалы и новые строки.

```php
<?php

class Talker
{
    use A;
    use B {
        A::smallTalk insteadof B;
    }
    use C {
        B::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}
```

###### 4.3 Свойства и Константы

Видимость ДОЛЖНА быть объявлена для всех свойств.

Видимость ДОЛЖНА быть объявлена для всех констант, если минимальная версия вашего проекта поддерживает видимость констант (PHP 7.1 и выше).

> Продолжение следует ...


[keywords]: https://www.php.net/manual/ru/reserved.keywords.php
[types]: https://www.php.net/manual/ru/reserved.other-reserved-words.php
