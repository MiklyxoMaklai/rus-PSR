## PSR-12: Расширенный Стиль Кодирования

Ключевые слова 'ДОЛЖНЫ', 'НЕ ДОЛЖНЫ', 'ТРЕБУЕТСЯ', 'НУЖНО', 'НЕ НУЖНО', 'СЛЕДУЕТ', 'НЕ СЛЕДУЕТ', 'РЕКОМЕНДУЕТСЯ', 'МОЖЕТ' и 'НЕОБЯЗАТЕЛЬНО' в этом документе должны толковаться так, как описано в [RFC 2119](../rfc2119.md).

#### 1. Обзор

Эта спецификация расширяет и заменяет руководство по стилю кодирования PSR-2 и требует соблюдения PSR-1, основного стандарта кодирования.

Как и PSR-2, цель данной рекомендации, уменьшить когнитивные трения при просмотре кода разных авторов. Это достигается путем перечисления общего набора правил и ожиданий о том, как форматировать код на PHP. Этот PSR стремится обеспечить набор способов, который может реализовать механизмы стиля кодирования. Проекты могут заявить о соблюдении, а разработчики могут легко устанавливать связь между различными проектами. Когда разные авторы имеют дело с несколькими проектами, это помогает иметь один набор стиля кодирования, который будет использоваться среди всех этих проектов. Таким образом, преимущество этого руководства заключается не в самих правилах, а в совместном использовании этих правил.

PSR-2 был принят в 2012 году, и с тех пор в PHP был внесен ряд изменений, которые повлияли на рекомендации по стилю кодирования. В то время как PSR-2 полно отражает функциональность PHP, существовавшую на момент написания, новая функциональность хорошо раскрыта для понимания. Таким образом, этот PSR стремится прояснить содержание PSR-2 в более современном контексте с доступными новыми функциональными возможностями и сделать поправки к PSR-2.

###### Предыдущие Версии Языка

На протяжении всего этого документа любые инструкции МОГУТ быть проигнорированы, если они не существуют в версиях PHP, поддерживаемых вашим проектом.

###### Пример

Этот пример включает в себя некоторые из приведенных ниже правил в качестве краткого обзора:

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;

use function Vendor\Package\{functionA, functionB, functionC};

use const Vendor\Package\{ConstantA, ConstantB, ConstantC};

class Foo extends Bar implements FooInterface
{
    public function sampleFunction(int $a, int $b = null): array
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // Тело метода
    }
}
```

#### 2. Общее

###### 2.1 Базовый Стандарт Кодирования

Код ДОЛЖЕН соответствовать всем правилам, изложенным в PSR-1.

Термин "StudlyCaps" в PSR-1 ДОЛЖЕН интерпретироваться как "PascalCase", где первая буква каждого слова пишется с большой буквы, включая самую первую букву.

###### 2.2 Файлы

Все файлы PHP ДОЛЖНЫ использовать только конец строки Unix LF (перевод строки).

Все файлы PHP ДОЛЖНЫ заканчиваться непустой строкой, заканчивающейся одним LF.

Закрывающий тег `?>` ДОЛЖЕН быть опущен в файлах, содержащих только PHP код.

###### 2.3 Строки

Здесть НЕ ДОЛЖНО быть жесткого ограничения на длину строки.

Слабое ограничение на длину строки ДОЛЖНО быть 120 символов.

Строки НЕ ДОЛЖНЫ быть длиннее 80 символов. Длинные строки ДОЛЖНЫ быть разбиты на несколько строк, длиной не более 80 символов.

В конце строк НЕ ДОЛЖНО быть завершающих пробелов.

Пустые строки МОГУТ быть добавлены для улучшения читабельности и для обозначения связанных блоков кода, за исключением случаев, когда это явно запрещено.

В каждой строке НЕ ДОЛЖНО быть более одного оператора.

###### 2.4 Отступ

В коде ДОЛЖЕН использоваться отступ в 4 пробела для каждого уровня отступа. Для отступа НЕ ДОЛЖНА использоваться табуляция.

###### 2.5 Ключевые Слова и Типы

Все зарезервированные в PHP [ключевые слова][keywords] и [типы][types] ДОЛЖНЫ быть в нижнем регистре.

Любые новые типы и ключевые слова, добавленные в будущих версиях PHP, ДОЛЖНЫ быть в нижнем регистре.

НЕОБХОДИМО использовать краткую форму ключевых слов типа, т.е. `bool` вместо `boolean`, `int` вместо `integer` и т. Д.

#### 3. Операторы declare, Пространства Имен и Операторы Импорта

Заголовок файла PHP может состоять из нескольких различных блоков. Если заголовок присутствует, каждый из нижеприведенных блоков ДОЛЖЕН быть разделен одной пустой строкой и блок НЕ ДОЛЖЕН содержать пустых строк. Каждый блок ДОЛЖЕН быть в указанном ниже порядке, если блоки неуместны, то могут быть опущены.

* Открывающий тег `<?php`.
* Файловый doc-блок.
* Одно или несколько операторов declare.
* Объявление пространства имен файла.
* Один или несколько операторов импорта `use` на основе классов.
* Один или несколько операторов импорта `use` на основе функций.
* Один или несколько операторов импорта `use` на основе констант.
* Остальная часть кода в файле.

Когда файл содержит комбинацию HTML и PHP, любой из вышеперечисленных блоков все еще может использоваться. Если это так, то блоки ДОЛЖНЫ присутствовать в верхней части файла, даже если остальная часть кода состоит из закрывающего тега PHP, и только потом комбинация HTML и PHP.

Открывающий тег `<?php` находится в первой строке файла, он ДОЛЖЕН находиться в отдельной строке без других операторов, если это не файл, содержащий разметку вне открывающих и закрывающих тегов PHP.

НЕДОПУСТИМО, чтобы инструкции импорта начинались с обратной косой черты, поскольку они всегда должны быть полными.

Следующий пример демонстрирует полный список всех блоков:

```php
<?php

/**
 * Этот файл содержит пример стилей кодирования.
 */

declare(strict_types=1);

namespace Vendor\Package;

use Vendor\Package\{ClassA as A, ClassB, ClassC as C};
use Vendor\Package\SomeNamespace\ClassD as D;
use Vendor\Package\AnotherNamespace\ClassE as E;

use function Vendor\Package\{functionA, functionB, functionC};
use function Another\Vendor\functionD;

use const Vendor\Package\{CONSTANT_A, CONSTANT_B, CONSTANT_C};
use const Another\Vendor\CONSTANT_D;

/**
 * FooBar - это примерный класс.
 */
class FooBar
{
    // ... вспомогательный код PHP ...
}
```

Составные пространства имен с глубиной более двух НЕ ДОЛЖНЫ использоваться. Ниже приведен максимальный компромисс допустимой глубины:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\ClassA,
    SubnamespaceOne\ClassB,
    SubnamespaceTwo\ClassY,
    ClassZ,
};
```

А следующие действия не допускаются:

```php
<?php

use Vendor\Package\SomeNamespace\{
    SubnamespaceOne\AnotherNamespace\ClassA,
    SubnamespaceOne\ClassB,
    ClassZ,
};
```

При желании установить директиву строгой типизации в файлах, содержащих разметку вне открывающих и закрывающих тегов PHP, установка ДОЛЖНА быть в первой строке файла и включать открывающий тег PHP, объявление строгой типизации и закрывающий тег.

Например:

```php
<?php declare(strict_types=1) ?>
<html>
<body>
    <?php
        // ... вспомогательный код PHP ...
    ?>
</body>
</html>
```

Операторы declare ДОЛЖНЫ не содержать пробелов и ДОЛЖНЫ быть такими `declare(strict_types=1)` (с необязательным оканчиванием точкой с запятой).

Блок операторов declare допускается и ДОЛЖЕН быть отформатирован следующим образом. Обратите внимание на положение фигурных скобок и пробелов:

```php
<?php
declare(ticks=1) {
    // некоторый код
}
```

#### 4. Классы, Методы и Свойства

Термин "класс" относится ко всем классам, интерфейсам и трейтам.

Любая закрывающая скобка НЕ ДОЛЖНА сопровождаться комментарием или оператором в той же строке.

При создании экземпляра нового класса круглые скобки ДОЛЖНЫ присутствовать всегда, даже если в конструктор не передаются никакие аргументы.

```php
new Foo();
```

###### 4.1 Наследование и Реализации Интерфейса

НЕОБХОДИМО, чтобы ключевые слова `extends` и `implements` были объявлены в той же строке, что и имя класса.

Открывающая скобка для класса ДОЛЖНА идти отдельной строкой; закрывающая скобка для класса ДОЛЖНА идти на следующей строке после тела.

Открывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать или сопровождаться пустой строкой.

Закрывающие фигурные скобки ДОЛЖНЫ быть на отдельной строке и НЕ ДОЛЖНЫ предшествовать пустой строкой.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // константы, свойства, методы
}
```

Расширение `implements` класса и реализации `extends` интерфейсов МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один интерфейс на строку.

```php
<?php

namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // константы, свойства, методы
}
```

###### 4.2 Использование Трейтов

Ключевое слово `use`, используемое внутри классов для реализации трейтов, ДОЛЖНО быть объявлено на следующей строке после открывающей скобки.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

Каждый отдельный трейт, который импортируется в класс, ДОЛЖЕН быть расположен на отдельной строке, и каждое включение ДОЛЖНО иметь свой собственный оператор `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;
use Vendor\Package\SecondTrait;
use Vendor\Package\ThirdTrait;

class ClassName
{
    use FirstTrait;
    use SecondTrait;
    use ThirdTrait;
}
```

Когда у класса ничего нет после оператора импорта `use`, закрывающая скобка класса ДОЛЖНА быть на следующей строке после оператора `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;
}
```

В противном случае он ДОЛЖЕН иметь пустую строку после оператора импорта `use`.

```php
<?php

namespace Vendor\Package;

use Vendor\Package\FirstTrait;

class ClassName
{
    use FirstTrait;

    private $property;
}
```

Операторы `insteadof` и `as` ДОЛЖНЫ использоваться следующим образом, принимая во внимание отступы, интервалы и новые строки.

```php
<?php

class Talker
{
    use A;
    use B {
        A::smallTalk insteadof B;
    }
    use C {
        B::bigTalk insteadof C;
        C::mediumTalk as FooBar;
    }
}
```

###### 4.3 Свойства и Константы

Видимость ДОЛЖНА быть объявлена для всех свойств.

Видимость ДОЛЖНА быть объявлена для всех констант, если минимальная версия вашего проекта поддерживает видимость констант (PHP 7.1 и выше).

Ключевое слово `var` НЕ ДОЛЖНО использоваться для объявления свойства.

В каждом выражении НЕ ДОЛЖНО быть объявлено более одного свойства.

Имена свойств НЕ ДОЛЖНЫ иметь префикс с одним подчеркиванием для обозначения защищенной или приватной видимости. Другими словами префикс подчеркивания явно не имеет значения.

Между объявлением типа и именем свойства ДОЛЖЕН быть пробел.

Объявление свойства выглядит следующим образом:

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public $foo = null;
    public static int $bar = 0;
}
```

###### 4.4 Методы и Функции

Видимость ДОЛЖНА быть объявлена для всех методов.

Названия методов НЕ ДОЛЖНЫ иметь префикс с одним подчеркиванием для обозначения защищенной или приватной видимости. То есть префикс подчеркивания явно не имеет значения.

Названия методов и функций НЕ ДОЛЖНЫ быть объявлены с пробелом после названия метода. Открывающая фигурная скобка ДОЛЖНА идти по отдельной строке, а закрывающая фигурная скобка ДОЛЖНА переходить на следующую строку после тела. После открывающей скобки НЕ ДОЛЖНО быть пробела, и НЕ ДОЛЖЕН быть пробел перед закрывающей скобкой.

Объявление метода выглядит следующим образом. Обратите внимание на расположение обычных и фигурных скобок, запятых, пробелов:

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

Объявление функции выглядит следующим образом. Обратите внимание на расположение обычных и фигурных скобок, запятых, пробелов:

```php
<?php

function fooBarBaz($arg1, &$arg2, $arg3 = [])
{
    // тело функции
}
```

###### 4.5 Аргументы Метода и Функции

В списке аргументов НЕ ДОЛЖЕН быть пробел перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

Аргументы метода и функции со значениями по умолчанию ДОЛЖНЫ помещаться в конец списка аргументов.

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function foo(int $arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

Списки аргументов МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН находиться на следующей строке, и в каждой строке ДОЛЖЕН быть только один аргумент.

Когда список аргументов разбит на несколько строк, закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть помещены вместе в их собственную строку с одним пробелом между ними.

```php
<?php

namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // тело метода
    }
}
```

При наличии объявления возвращаемого типа после двоеточия, за которым следует объявление типа, ДОЛЖЕН быть один пробел. Двоеточие и объявление ДОЛЖНЫ находиться в той же строке, что и закрывающая скобка списка аргументов, без пробелов между двумя символами.

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(int $arg1, $arg2): string
    {
        return 'foo';
    }

    public function anotherFunction(
        string $foo,
        string $bar,
        int $baz
    ): string {
        return 'foo';
    }
}
```

В объявлениях типа Nullable НЕ ДОЛЖЕН быть пробел между знаком вопроса и типом.

```php
<?php

declare(strict_types=1);

namespace Vendor\Package;

class ReturnTypeVariations
{
    public function functionName(?string $arg1, ?int &$arg2): ?string
    {
        return 'foo';
    }
}
```

При использовании оператора ссылки `&` перед аргументом НЕ ДОЛЖНО быть пробел после него, как и в предыдущем примере.

Между оператором многоточие `...` и именем аргумента не должно быть пробела:

```php
public function process(string $algorithm, ...$parts)
{
    // обработка
}
```

При объединении как оператора ссылки, так и оператора многоточие между ними не должно быть никакого пространства:

```php
public function process(string $algorithm, &...$parts)
{
    // обработка
}
```

###### 4.6 abstract, final, and static

Когда присутствуют, абстрактные `abstract` и окончательные `final` объявления они ДОЛЖНЫ предшествовать объявлению видимости.

При наличии статического объявления `static`, оно ДОЛЖНО следовать за объявлением видимости.

```php
<?php

namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // тело метода
    }
}
```

###### 4.7 Вызовы Методов и Функций

При вызове метода или функции не ДОЛЖНО быть пробела между именем метода или функции и открывающей скобкой, НЕ ДОЛЖНО быть пробела и после открывающей скобки и НЕ ДОЛЖНО быть пробела перед закрывающей скобкой. В списке аргументов перед каждой запятой НЕ ДОЛЖНО быть пробела, а после каждой запятой ДОЛЖЕН быть один пробел.

```php
<?php

bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);
```

Списки аргументов МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент списка ДОЛЖЕН находиться на следующей строке, и в каждой строке ДОЛЖЕН быть только один аргумент. Один аргумент, разбитый на несколько строк (как это может быть в случае с анонимной функцией или массивом), не является разбиением самого списка аргументов.

```php
<?php

$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
```

```php
<?php

somefunction($foo, $bar, [
  // ...
], $baz);

$app->get('/hello/{name}', function ($name) use ($app) {
    return 'Hello ' . $app->escape($name);
});
```

#### 5. Управляющие Конструкции

Общие правила стиля для управляющих конструкций следующие:

* После ключевого слова управляющей конструкции ДОЛЖЕН быть один пробел
* После открывающей скобки НЕ ДОЛЖНО быть пробела
* Перед закрывающей скобкой НЕ ДОЛЖНО быть пробела
* Между закрывающей скобкой и открывающей скобкой ДОЛЖЕН быть один пробел
* Тело конструкции ДОЛЖНО иметь один отступ (4 пробела)
* Тело ДОЛЖНО быть на следующей строке после открывающей скобки
* Закрывающая скобка ДОЛЖНА быть на следующей строке после тела

Тело каждой конструкции ДОЛЖНО быть заключено в фигурные скобки. Это стандартизирует внешний вид конструкций и снижает вероятность появления ошибок при добавлении новых строк в тело.

###### 5.1 if, elseif, else

Конструкция `if` выглядит следующим образом. Обратите внимание на размещение скобок, пробелов и фигурных скобок, и что `else` и `elseif` находятся на той же строке, что и закрывающая скобка из предыдущего тела.

```php
<?php

if ($expr1) {
    // тело if
} elseif ($expr2) {
    // тело elseif
} else {
    // тело else
}
```

Ключевое слово `elseif` ДОЛЖНО использоваться вместо `else if`, чтобы все управляющие ключевые слова выглядели как единые слова.

Выражения в круглых скобках МОГУТ быть разбиты на несколько строк, где каждая последующая строка имеет хотя бы один отступ. При этом первое условие ДОЛЖНО быть на следующей строке. Закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть размещены вместе на отдельной строке с одним пробелом между ними. Булевы операторы между условиями всегда ДОЛЖНЫ находиться в начале или в конце строки, а не сочетание того и другого.


```php
<?php

if (
    $expr1
    && $expr2
) {
    // тело if
} elseif (
    $expr3
    && $expr4
) {
    // тело elseif 
}
```

###### 5.2 switch, case

Конструкция `switch` выглядит следующим образом. Обратите внимание на расположение пробелов, обычных и фигурных скобок. Оператор `case` ДОЛЖЕН начинаться с одного отступа от` switch`. Ключевое слово `break` (или другое завершающее ключевое слово) ДОЛЖНО иметь отступ на том же уровне, что и тело `case`. В непустом теле` case` ДОЛЖЕН быть комментарий, такой как `// no break`, когда пропуск является сознательным.

```php
<?php

switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}
```

Выражения в скобках МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет хотя бы один отступ. При этом первое выражение ДОЛЖНО быть на следующей строке. Закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть размещены вместе на отдельной строке с одним пробелом между ними. НЕОБХОДИМО, чтобы булевы операторы между условиями всегда были в начале или в конце строки, а не сочетание того и другого.

```php
<?php

switch (
    $expr1
    && $expr2
) {
    // конструкция тела
}
```

###### 5.3 while, do while

Оператор `while` выглядит следующим образом. Обратите внимание на размещение пробелов, обычных и фигурных скобок.

```php
<?php

while ($expr) {
    // конструкция тела
}
```

Выражения в скобках МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет хотя бы один отступ. При этом первое условие ДОЛЖНО быть на следующей строке. Закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть размещены вместе на отдельной строке с одним пробелом между ними. НЕОБХОДИМО, чтобы булевы операторы между условиями всегда были в начале или в конце строки, а не сочетание того и другого.

```php
<?php

while (
    $expr1
    && $expr2
) {
    // конструкция тела
}
```

Аналогично, оператор `do while` выглядит следующим образом. Обратите внимание на расположение пробелов, обычных и фигурных скобок.

```php
<?php

do {
    // конструкция тела
} while ($expr);
```

Выражения в скобках МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет хотя бы один отступ. При этом первое условие ДОЛЖНО быть на следующей строке. НЕОБХОДИМО, чтобы булевы операторы между условиями всегда были в начале или в конце строки, а не сочетание того и другого.

```php
<?php

do {
    // конструкция тела
} while (
    $expr1
    && $expr2
);
```

###### 5.4 for

Оператор `for` выглядит следующим образом. Обратите внимание на размещение пробелов, обычных и фигурных скобок.

```php
<?php

for ($i = 0; $i < 10; $i++) {
    // тело for
}
```

Выражения в скобках МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет хотя бы один отступ. При этом первое выражение ДОЛЖНО быть на следующей строке. Закрывающая скобка и открывающая фигурная скобка ДОЛЖНЫ быть размещены вместе на отдельной строке с одним пробелом между ними.

```php
<?php

for (
    $i = 0;
    $i < 10;
    $i++
) {
    // тело for
}
```

###### 5.5 foreach

Оператор `foreach` выглядит следующим образом. Обратите внимание на размещение пробелов, обычных и фигурных скобок.

```php
<?php

foreach ($iterable as $key => $value) {
    // тело foreach
}
```

###### 5.6 try, catch, finally

Блок `try-catch-finally` выглядит следующим образом. Обратите внимание на размещение пробелов, обычных и фигурных скобок.

```php
<?php

try {
    // тело try
} catch (FirstThrowableType $e) {
    // тело catch
} catch (OtherThrowableType | AnotherThrowableType $e) {
    // тело catch
} finally {
    // тело finally
}
```

#### 6. Операторы

Правила стиля для операторов сгруппированы по арности (количество операндов, которые они принимают).

Если вокруг оператора разрешены пробелы, то МОЖНО использовать несколько пробелов для удобства чтения.

Все операторы, не описанные здесь, остаются неопределенными.

###### 6.1. Унарный Оператор

Операторы инкремента/декремента не должны иметь никакого пробела между оператором и операндом.

```php
$i++;
++$j;
```

Операторы приведения типов не должны иметь пробелов в круглых скобках:
```php
$intValue = (int) $input;
```

###### 6.2. Бинарные Операторы

Для всех бинарных операторов таких как:
[арифметические][arithmetic],
[сравнения][comparison],
[присваивания][assignment],
[побитовые][bitwise],
[логические][logical],
[строковые][string] и 
[операторы проверки типа][type]
до и после таких операторов ДОЛЖЕН быть хотя бы один пробел:

```php
if ($a === $b) {
    $foo = $bar ?? $a ?? $b;
} elseif ($a > $b) {
    $foo = $a + $b * $c;
}
```

###### 6.3. Тернарный Оператор

Условный оператор, известный как тернарный оператор, ДОЛЖЕН быть окружен вокруг обоих символов `?` и `:` по крайней мере одним пробелом:

```php
$variable = $foo ? 'foo' : 'bar';
```

Если средний операнд тернароного оператора опущен, то оператор ДОЛЖЕН следовать тем же правилам стиля, что и другие бинарные операторы [сравнения][comparison]:

```php
$variable = $foo ?: 'bar';
```

#### 7. Замыкания

Замыкания ДОЛЖНЫ быть объявлены с пробелом после ключевого слова `function`, а также пробелом до и после ключевого слова `use`.

Открывающая скобка ДОЛЖНА находиться на той же строке, а закрывающая скобка ДОЛЖНА идти на новой строке после тела.

После открывающей скобки списка аргументов или списка переменных НЕ ДОЛЖНО быть пробела, и перед закрывающей скобкой списка аргументов или списка переменных НЕ ДОЛЖНО быть пробела.

В списке аргументов и списке переменных НЕ ДОЛЖНО быть пробела перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

Аргументы замыкания со значениями по умолчанию ДОЛЖНЫ располагаться в конец списка аргументов.

Если возвращаемый тип присутствует, то он ДОЛЖЕН следовать тем же правилам, что и обычные функции и методы. При наличии ключевого слова `use`, двоеточие должно следовать за закрывающими скобками списка `use` без пробелов между двумя символами.

Объявление замыкания выглядит следующим образом. Обратите внимание на размещение запятых, пробелов, обычных и фигурных скобок:

```php
<?php

$closureWithArgs = function ($arg1, $arg2) {
    // тело
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // тело
};

$closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool {
    // тело
};
```

Список аргументов и список переменных МОГУТ разбиваться на несколько строк, где каждая последующая строка имеет один отступ. При этом первый элемент в списке ДОЛЖЕН находиться на следующей строке, и в каждой строке ДОЛЖЕН быть только один аргумент или переменная.

Когда конечный список (будь то аргументы или переменные) разделен на несколько строк, закрывающая скобка и открывающая скобка ДОЛЖНЫ быть помещены вместе в отдельной строке с одним пробелом между ними.

Ниже приведены примеры замыканий со списком аргументов и без них, а также список переменных, разбитых на несколько строк.

```php
<?php

$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // тело
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // тело
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело
};
```

Обратите внимание, что правила форматирования также применяются, когда замыкание используется непосредственно в вызове функции или метода в качестве аргумента.

```php
<?php

$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // тело
    },
    $arg3
);
```

#### 8. Анонимные классы

Анонимные классы ДОЛЖНЫ следовать тем же правилам и принципам, что и замыкания в приведенном выше разделе.

```php
<?php

$instance = new class {};
```

Открывающая скобка МОЖЕТ находиться в той же строке, что и ключевое слово `class`, если список интерфейсов `implements` не переносится. Если список интерфейсов переносится, фигурная скобка ДОЛЖНА быть помещена в строку сразу после последнего интерфейса.

```php
<?php

// Скобка на той же строке
$instance = new class extends \Foo implements \HandleableInterface {
    // Содержимое класса
};

// Скобка на новой строке
$instance = new class extends \Foo implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // Содержимое класса
};
```

[keywords]: https://www.php.net/manual/ru/reserved.keywords.php
[types]: https://www.php.net/manual/ru/reserved.other-reserved-words.php
[arithmetic]: https://www.php.net/manual/ru/language.operators.arithmetic.php
[comparison]: https://www.php.net/manual/ru/language.operators.comparison.php
[assignment]: https://www.php.net/manual/ru/language.operators.assignment.php
[bitwise]: https://www.php.net/manual/ru/language.operators.bitwise.php
[logical]: https://www.php.net/manual/ru/language.operators.logical.php
[string]: https://www.php.net/manual/ru/language.operators.string.php
[type]: https://www.php.net/manual/ru/language.operators.type.php
