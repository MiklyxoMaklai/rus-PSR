## PSR-3: Интерфейс Протоколирования (Логирования)

Этот документ описывает общий интерфейс для библиотек ведения логирования.

Основная цель, это позволить библиотекам получать объект `Psr\Log\LoggerInterface` и записывать в него логи простым и универсальным способом. Фреймворки и CMS, которые имеют пользовательские потребности, МОГУТ расширить интерфейс для своих собственных целей, и ДОЛЖНЫ остаться совместимыми с этим документом. Это гарантирует, что сторонние библиотеки, используемые приложением, могут записывать данные в централизованные логи приложений.

Под словом 'разработчик' в этом документе следует понимать человека, реализующего интерфейс `LoggerInterface` в библиотеке или фреймворке, относящихся к логу. Пользователи систем логирования упоминаются как `пользователь`.

#### 1. Спецификация

###### 1.1 Основы

* `LoggerInterface` предоставляет восемь методов, чтобы писать логи на восемь уровней [RFC 5424][rfc5424] (отладочный, информационный, уровень уведомлений, уровень предупреждений, уровень ошибок, критический, уровень предупреждений, аварийный).

* Девятый метод, `log`, принимает уровень лога в качестве первого аргумента. Вызов этого метода с одной из констант уровня лога ДОЛЖЕН иметь тот же результат, что и вызов метода определенный для данного уровня. Вызов этого метода с уровнем, не определенным в этой спецификации, ДОЛЖЕН вызвать исключение `Psr\Log\InvalidArgumentException`, если реализация не знает об уровне. Пользователям НЕ СЛЕДУЕТ использовать пользовательский уровень, точно не зная, что текущая реализация его поддерживает.

###### 1.2 Сообщение

* Каждый метод принимает строку в качестве сообщения или объект с методом `__toString()`. Разработчики МОГУТ иметь специальную обработку для передаваемых объектов. Если это не так, разработчики ДОЛЖНЫ привести объект к строке.

* Сообщение МОЖЕТ содержать заполнители, которые разработчики МОГУТ заменить на значения из массива `context`.

* Имена заполнителей ДОЛЖНЫ соответствовать ключам в массиве `context`.

* Имена заполнителей ДОЛЖНЫ быть разделены одной открывающей скобкой `{` и одной закрывающей скобкой `}`. Между разделителями и именем заполнителя НЕ ДОЛЖНО быть пробелов.

* Имена заполнителей СЛЕДУЕТ составлять только из символов `A-Z`, `a-z`, `0-9`, подчеркивания `_` и точки `.`. Использование других символов зарезервировано для будущих модификаций спецификации заполнителей.

* Разработчики МОГУТ использовать заполнители для реализации различных стратегий экранирования и передачи логов для отображения. Пользователям НЕ СЛЕДУЕТ предварительно экранировать значения заполнителей, поскольку они не могут знать, в каком контексте будут отображаться данные.

    Ниже приведен пример реализации подстановки заполнителя, предоставленный только для справочных целей:

    ```php
    <?php

    /**
     * Подставляет значения context в заполнители сообщения.
     */
    function interpolate($message, array $context = array())
    {
        // создаем заменяемый массив с фигурными скобками вокруг ключей массива context
        $replace = array();
        foreach ($context as $key => $val) {
            // проверяем, что значение может быть приведено к строке
            if (!is_array($val) && (!is_object($val) || method_exists($val, '__toString'))) {
                $replace['{' . $key . '}'] = $val;
            }
        }

        // подставляем значения замены в сообщение и возвращаем его
        return strtr($message, $replace);
    }

    // сообщение с разделенными фигурными скобками именем заполнителя
    $message = "User {username} created";

    // массив context для заполнителя, название => замещающие значения
    $context = array('username' => 'bolivar');

    // выведет "User bolivar created"
    echo interpolate($message, $context);
    ```

###### 1.3 Context

* Каждый метод принимает массив в качестве данных `context`. Он предназначен для хранения любой посторонней информации, которая плохо вписывается в строку. Массив может содержать все что угодно. Разработчики ДОЛЖНЫ гарантировать, что они обрабатывают данные в `context` снисходительно насколько это возможно. Заданное значение в `context` НЕ ДОЛЖНО вызывать исключение и не выдавать никаких ошибок PHP, предупреждений или уведомлений.

* Если объект `Exception` передается в данных `context`, то он ДОЛЖЕН быть расположен в ключе `'exception'`. Ведение логов исключений является распространенным шаблоном. Это позволяет разработчикам извлекать трассировку стека от исключения, если система логирования поддерживает такую функциональность. Разработчики ДОЛЖНЫ убедиться, что ключ `'exception'` на самом деле является `Exception`, прежде чем использовать его как таковой, поскольку он МОЖЕТ содержать что угодно.

###### 1.4 Вспомогательные Классы и Интерфейсы

* Класс `Psr\Log\AbstractLogger` позволяет очень легко реализовать интерфейс `LoggerInterface`, расширив его и реализовав универсальный метод `log`. Остальные восемь методов - это пересылка сообщения и `context` к нему.

* Точно так же использование `Psr\Log\LoggerTrait` требует только реализации универсального метода `log`. Обратите внимание, что поскольку трейты не могут реализовывать интерфейсы, в этом случае вам все равно нужно реализовать `LoggerInterface`.

* Класс `Psr\Log\NullLogger` предоставляется вместе с интерфейсом. Он МОЖЕТ использоваться пользователями интерфейса для обеспечения реализации 'черной дыры', если им не предоставляется система логирования. Однако, условное ведение лога может быть лучшим подходом, если создание данных является затратным.

* Интерфейс `Psr\Log\LoggerAwareInterface` содержит только метод `setLogger(LoggerInterface $logger)` и может использоваться фреймворками для автоматической привязки произвольных экземпляров к системе логирования.

* Трейт `Psr\Log\LoggerAwareTrait` может использоваться для простой реализации равнозначного интерфейса в любом классе. Это дает вам доступ к `$this->logger`.

* Класс `Psr\Log\LogLevel` содержит константы для восьми уровней лога.

#### 2. Package

Описанные интерфейсы и классы, а также соответствующие классы исключений и набор тестов для проверки вашей реализации предоставляются в составе пакета [psr/log][logpckg].

#### 3. Интерфейс Psr\Log\LoggerInterface

```php
<?php

namespace Psr\Log;

/**
 * Описывает экземпляр системы логирования.
 *
 * Сообщение ДОЛЖНО быть строкой или объектом, реализующим __toString().
 *
 * Сообщение МОЖЕТ содержать заполнители в формате: {foo},
 * где foo будет заменен данными из context по ключу "foo".
 *
 * Массив context может содержать произвольные данные,
 * единственное предположение, которое может быть сделано
 * разработчиками, заключается в том, что если для исключения
 * трассировки стека задан экземпляр Exception, он ДОЛЖЕН
 * находиться в ключе с именем "exception".
 */
interface LoggerInterface
{
    /**
     * Система непригодна для использования.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function emergency($message, array $context = array());

    /**
     * Действие должно быть принято немедленно.
     *
     * Пример: весь сайт упал, база данных недоступна и т. д.
     * Это должно вызвать оповещения SMS и пробудить вас.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function alert($message, array $context = array());

    /**
     * Критические состояния.
     *
     * Пример: компонент приложения недоступен, непредвиденное исключение.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function critical($message, array $context = array());

    /**
     * Ошибки во время выполнения, которые не требуют немедленных действий,
     * но, как правило, должны логироваться и отслеживаться.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function error($message, array $context = array());

    /**
     * Исключительные случаи, которые не являются ошибками.
     *
     * Пример: использование устаревших API, плохое использование API,
     * нежелательные вещи, которые не обязательно являются ошибочными.
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function warning($message, array $context = array());

    /**
     * Обычные значимые события
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function notice($message, array $context = array());

    /**
     * Интересные события
     *
     * Пример: вход пользователя в систему, логи SQL
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function info($message, array $context = array());

    /**
     * Подробная отладочная информация
     *
     * @param string $message
     * @param array $context
     * @return void
     */
    public function debug($message, array $context = array());

    /**
     * Логи с произвольным уровнем.
     *
     * @param mixed $level
     * @param string $message
     * @param array $context
     * @return void
     */
    public function log($level, $message, array $context = array());
}
```

#### 4. Интерфейс Psr\Log\LoggerAwareInterface

```php
<?php

namespace Psr\Log;

/**
 * Описывает экземпляр поддерживающий логирование.
 */
interface LoggerAwareInterface
{
    /**
     * Устанавливает экземпляр логгера в объект.
     *
     * @param LoggerInterface $logger
     * @return void
     */
    public function setLogger(LoggerInterface $logger);
}
```

#### 5. Класс Psr\Log\LogLevel

```php
<?php

namespace Psr\Log;

/**
 * Описание уровней логирования
 */
class LogLevel
{
    const EMERGENCY = 'emergency';
    const ALERT     = 'alert';
    const CRITICAL  = 'critical';
    const ERROR     = 'error';
    const WARNING   = 'warning';
    const NOTICE    = 'notice';
    const INFO      = 'info';
    const DEBUG     = 'debug';
}
```

[rfc5424]: https://tools.ietf.org/html/rfc5424
[logpckg]: https://packagist.org/packages/psr/log
